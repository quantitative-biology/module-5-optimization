---
title: "Dataset"
output: html_document
---

```{r}
library(deSolve)

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = x*(alpha - beta*y)
        dy = -y*(gamma - delta*x)
        return(list(c(dx, dy)))
    })
}

Pars <- c(alpha = 30, beta = 5, gamma = 2, delta = 6)
State <- c(x = 8.792889e-3, y = 1.595545)
Time <- seq(0, 6, by = 0.01)

out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))

matplot(out[,-1], type = "l", xlab = "time", ylab = "population")
out
ss<-sum(residuals(out)^2)
ss

x<-out$x[seq(1,length(out$x),20)]
y<-out$y[seq(1,length(out$y),20)]
t<-out$time[seq(1,length(out$time),20)]
y
x
data1<-data.frame(a<-out$time[seq(1,length(out$time),20)],
                  b<-out$x[seq(1,length(out$x),20)],
                  c<-out$y[seq(1,length(out$y),20)])
data1
set.seed(12)
random<-runif(20)

set.seed(13)
random1<-runif(20)
data2<-data.frame(a<-out$time[seq(1,length(out$time),20)],
                  b<-((random*2-1)*(0.1*x)),
                  c<-((random1*2-1)*(0.1*y)))
data2
data3<-data2
colnames(data3)<-colnames(data1)
sim<-rbind(data1,data3)
sim
plot(out$y~out$time, type = "l")
points(out$x~out$time, type = "l", add = TRUE)
```

```{r}
set.seed(1)
random<-runif(20)
random
```

```{r}
library(deSolve)

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = x*(alpha - beta*y)
        dy = -y*(gamma - delta*x)
        return(list(c(dx, dy)))
    })
}

Pars <- c(alpha = 30, beta = 5, gamma = 2, delta = 6)
State <- c(x = 8.792889e-3, y = 1.595545)
Time <- seq(0, 6, by = 0.01)

out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))

x<-out$x[seq(1,length(out$x),20)]
y<-out$y[seq(1,length(out$y),20)]
y
x
data1<-data.frame(a<-out$x[seq(1,length(out$x),20)],
                 b<-out$y[seq(1,length(out$y),20)])
data1
data2<-data.frame(a<-((runif(20)*2-1)*0.1*x),
                  b<-((runif(20)*2-1)*0.1*y))
data2
data3<-data2
colnames(data3)<-colnames(data1)
sim<-rbind(data1,data3)
sim

library(deSolve)
determine_sse <- function(p1,p2,p3,p4,p5,p6) {
  Pars <- c(p1,p2,p3,p4)
State <- c(p5,p6)
Time <- seq(0, 6, by = .01)
LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = p5*(p1 - p2*p6)
        dy = -p6*(p3 - p4*p5)
        return(list(c(dx, dy)))
    })
}
  out1 <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
  x1<-out1$x[seq(1,length(out1$x),20)]
  y1<-out1$y[seq(1,length(out1$y),20)]
  data4<-data.frame(c<-out1$x[seq(1,length(out1$x),20)],
                    d<-out1$y[seq(1,length(out1$y),20)])
  data5<-data.frame(c<-((runif(20)*2-1)*0.1*x1),
                    d<-((runif(20)*2-1)*0.1*y1))
  data6<-data5
  colnames(data6)<-colnames(data4)
  sim2<-rbind(data4,data6)
  sse<-sum((fitted(sim)-sim$a)^2)
  return(sse)
}
sse
matplot(data,pch = 1)
matplot(out[,-1], type = "l", xlab = "time", ylab = "population", add = TRUE)
determine_sse(p1=30,p2=5,p3=2,p4=6,p5=8.792889e-3,p6=1.595545)
#get function working
#give user opportunity to use sse function, put in individual parameters, let them see quality of fit
```

```{r}
S <- 2
alpha <- .01
r <- runif(S)*2
a <- matrix(rnorm(S^2, m=alpha, sd=alpha/10), nrow=S, ncol=S)
parms <- list(r,a)
t=seq(0,40, by=.1)
N0 <- runif(S)/(S*alpha)
library(deSolve)
lvout <- ode(N0, t, lvcompg, parms)
matplot(t, lvout[,-1], type = "l", ylab="N", log='y')
```

```{r}
library(reshape2) # library for reshaping data (tall-narrow <-> short-wide)
library(deSolve) # library for solving differential equations
library(minpack.lm) # library for least squares fit using levenberg-marquart algorithm

library(deSolve)

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = x*(alpha - beta*y)
        dy = -y*(gamma - delta*x)
        return(list(c(dx, dy)))
    })
}

Pars <- c(alpha = 30, beta = 5, gamma = 2, delta = 6)
State <- c(x = 8.792889e-3, y = 1.595545)
Time <- seq(0, 6, by = 0.01)

out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))

matplot(out[,-1], type = "l", xlab = "time", ylab = "population")
out

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = x*(alpha - beta*y)
        dy = -y*(gamma - delta*x)
        return(list(c(dx, dy)))
    })
}

Pars <- c(alpha = 30, beta = 5, gamma = 2, delta = 6)
State <- c(x = 8.792889e-3, y = 1.595545)
Time <- out$time

out1 <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))

ssq = function(parms){
  State
  Time = c(seq(0,6,by=0.01),out$time)
  Time = sort(unique(Time))
  Pars
  out2 = ode(y=State,times=Time,func=LotVmod,parms=Pars)
  outdf=data.frame(out1)
  outdf=outdf[outdf$time %in% out$time,]
  preddf=melt(outdf,id.var="time",variable.name="species",value.name="density")
  expdf=melt(outdf,id.var="time",variable.name="species",value.name="density")
  ssqres=preddf$density-expdf$density
  return(ssqres)
}

parms = c(alpha = 30, beta = 6, gamma = 2, delta = 6)
fival = nls.lm(par = parms, fn = ssq)

fival
```

```{r}
library(deSolve)

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = x*(alpha - beta*y)
        dy = -y*(gamma - delta*x)
        return(list(c(dx, dy)))
    })
}

Pars <- c(alpha = 30, beta = 5, gamma = 2, delta = 6)
State <- c(x = 8.792889e-3, y = 1.595545)
Time <- seq(0, 6, by = 0.01)

out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
out

matplot(out[,-1], type = "l", xlab = "time", ylab = "population")

x<-out$x[seq(1,length(out$x),20)]
y<-out$y[seq(1,length(out$y),20)]
t<-out$time[seq(1,length(out$time),20)]

data1<-data.frame(b<-out$x[seq(1,length(out$x),20)],
                  c<-out$y[seq(1,length(out$y),20)])
data1
set.seed(12)
random<-runif(20)

set.seed(13)
random1<-runif(20)
data2<-data.frame(b<-((random*2-1)*(0.1*x)),
                  c<-((random1*2-1)*(0.1*y)))
data2
data3<-data2
colnames(data3)<-colnames(data1)
sim<-rbind(data1,data3)
sim
sim[,2]

nominalcorrupteddata<-sum(data1,data2)
nominalcorrupteddata

ssq = function(p){
  #Time = c(seq(0,6,by=0.01))
  #Time = sort(unique(Time))
  #Pars1
  outuser = ode(y=State,times=Time,func=LotVmod,parms=p)
  x1user<-outuser$x[seq(1,length(outuser$x),20)]
  y1user<-outuser$y[seq(1,length(outuser$y),20)]
  
  xerrors<-(nominalcorrupteddata[,1]-x1user)^2
  yerrors<-(nominalcorrupteddata[,2]-y1user)^2
  
  sum(xerrors)+sum(yerrors)

  #outdf=data.frame(sim1)
  #preddf=melt(outdf,id.var="sim1$d....out1.time.seq.1..length.out1.time...20..,variable".name="species",value.name="density")
  #expdf=melt(sim,id.var=sim$a....out.time.seq.1..length.out.time...20..,variable.name="species",value.name="density")
  #ssqres=preddf$density-expdf$density
  #ssqres=1
  return(xerrors+yerrors)
}

ssq(c(1,1,1,1,1,1))
#fitval = nls.lm(par = Pars1, fn = ssq)

#fitval
```

```{r}
library(deSolve)

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = x*(alpha - beta*y)
        dy = -y*(gamma - delta*x)
        return(list(c(dx, dy)))
    })
}

Pars <- c(alpha = 30, beta = 5, gamma = 2, delta = 6)
State <- c(x = 8.792889e-3, y = 1.595545)
Time <- seq(0, 6, by = 0.01)

out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))

x<-out$x[seq(1,length(out$x),20)]
y<-out$y[seq(1,length(out$y),20)]

data1<-data.frame(b<-out$x[seq(1,length(out$x),20)],
                  c<-out$y[seq(1,length(out$y),20)])
data1

set.seed(13)
random<-runif(20)

set.seed(14)
random1<-runif(20)
data2<-data.frame(b<-((random*2-1)*(0.1*x)),
                  c<-((random1*2-1)*(0.1*y)))
data2
nominalcorrupteddata1<-data.frame(data1+data2)
nominalcorrupteddata1

Pars1 <- c(alpha = 35, beta = 6, gamma = 3, delta = 8)
State1 <- c(x = 8.792889e-3, y = 1.595545)
Time1 <- seq(0, 6, by = 0.01)

outuser<- as.data.frame(ode(func = LotVmod, y = State1, parms = Pars1, times = Time1))

x1user<-outuser$x[seq(1,length(outuser$x),20)]
y1user<-outuser$y[seq(1,length(outuser$y),20)]

data3<-data.frame(d<-x1user,
                  e<-y1user)

data3

xerrors<-(nominalcorrupteddata1[,1]-data3$d....x1user)^2
yerrors<-(nominalcorrupteddata1[,2]-data3$e....y1user)^2

sum(xerrors,yerrors)
```

```{r}
library(deSolve)

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = p5*(p1 - p2*p6)
        dy = -p6*(p3 - p4*p5)
        return(list(c(dx, dy)))
    })
}

Pars <- c(p1 = 30, p2 = 5, p3 = 2, p4 = 6)
State <- c(p5 = 8.792889e-3, p6 = 1.595545)
Time <- seq(0, 6, by = 0.01)

out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))

x<-out$p5[seq(1,length(out$p5),20)]
y<-out$p6[seq(1,length(out$p6),20)]

data1<-data.frame(b<-out$p5[seq(1,length(out$p5),20)],
                  c<-out$p6[seq(1,length(out$p6),20)])
data1

set.seed(13)
random<-runif(20)

set.seed(14)
random1<-runif(20)
data2<-data.frame(b<-((random*2-1)*(0.1*x)),
                  c<-((random1*2-1)*(0.1*y)))
data2
nominalcorrupteddata1<-data.frame(data1+data2)
nominalcorrupteddata1

determine_sse1 = function(p1,p2,p3,p4,p5,p6) {
  Pars3 <- c(p1,p2,p3,p4)
  State3 <- c(p5,p6)
  out3 <- as.data.frame(ode(func = LotVmod, y = State3, parms = Pars3, times = Time))
  return(out3)
}
```

```{r}
library(deSolve)

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = p5*(p1 - p2*p6)
        dy = -p6*(p3 - p4*p5)
        return(list(c(dx,dy)))
    })
}

Pars <- c(p1 = 30, p2 = 5, p3 = 2, p4 = 6)
State <- c(p5 = 8.792889e-3, p6 = 1.595545)
Time <- seq(0, 6, by = 0.01)

out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))

x<-out$p5[seq(1,length(out$p5),20)]
y<-out$p6[seq(1,length(out$p6),20)]

data1<-data.frame(b<-out$p5[seq(1,length(out$p5),20)],
                  c<-out$p6[seq(1,length(out$p6),20)])
data1

set.seed(13)
random<-runif(20)

set.seed(14)
random1<-runif(20)
data2<-data.frame(b<-((random*2-1)*(0.1*x)),
                  c<-((random1*2-1)*(0.1*y)))
data2
nominalcorrupteddata1<-data.frame(data1+data2)
nominalcorrupteddata1

determine_sse1 = function(p1,p2,p3,p4,p5,p6) {
  Pars3 <- c(p1,p2,p3,p4)
  State3 <- c(p5,p6)
  LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = p5*(p1 - p2*p6)
        dy = -p6*(p3 - p4*p5)
        return(list(c(dx,dy)))
    })}
  outuser <- as.data.frame(ode(func = LotVmod, y = State3, parms = Pars3, times = Time))
  x2user<-outuser$p5[seq(1,length(outuser$p5),20)]
  y2user<-outuser$p6[seq(1,length(outuser$p6),20)]

  data4<-data.frame(d<-x2user,
                    e<-y2user)
  
  xerrors<-(nominalcorrupteddata1[,1]-data4$d....x2user)^2
  yerrors<-(nominalcorrupteddata1[,2]-data4$e....y2user)^2

  RSS <- sum(xerrors,yerrors)
  return(RSS)
}

determine_sse1(20,5,6,7,7,9)
```

```{r}
library(deSolve)
determine_sse1 = function(p1,p2,p3,p4,p5,p6) {
  Pars3 <- c(p1,p2,p3,p4)
  State3 <- c(p5,p6)
  LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = x*(p1 - p2*y)
        dy = -y*(p3 - p4*x)
        return(list(c(dx,dy)))
    })}
  outuser <- as.data.frame(ode(func = LotVmod, y = State3, parms = Pars3, times = Time))
  return(outuser)
}

LotVmod()

determine_sse1(1,2,3,4,5,6)
```

```{r}

LotVmod <- function (Time, State, Pars) {
    with(as.list(c(State, Pars)), {
        dx = p5*(p1 - p2*p6)
        dy = -p6*(p3 - p4*p5)
        return(list(c(dx,dy)))
    })
}

Pars <- c(p1 = 1, p2 = 2, p3 = 3, p4 = 4)
State <- c(p5 = 5, p6 = 6)
Time <- seq(0, 6, by = 0.01)

out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
out
```

